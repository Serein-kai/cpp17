/*
7.计算机科学家和数学讲师在介绍递归时，非常喜欢使用所谓的斐波那契函数。斐波那契函数计算著名的斐波那契数列中的第n个值。
这是一个正整数序列，其特征是前两个数字之后的每个数字都是之前的两个数字的和。
对于n>=1，该序列的定义如下:
1,1, 2,3，5，8，13，21， 34， 55，89, 144， 233, 377, 610, 987， 1597, 2584， 4181..
为了方便使用，计算机科学家还定义了一个额外的第 0 个斐波那契数字，其值为 0。
编写一个函数来递归地计算第n个斐波那契数字。
使用一个简单的程序来测试该函数，让用户决定要计算多少个数字，然后逐个输出每个数字，并将每个数字显示在单独的一行中。

附加题:虽然斐波那契函数的朴素递归版本很优雅，几乎与其数学定义完全对应，但是执行速度很慢。
如果让计算机计算 100 个斐波那契数字，你会注意到随着 越来越大，计算速度越来越慢。读者是否能够重写这个函数来使用循环而不是递归?
现在能够正确地计算多少个数字?
提示: 在循环的每次选代中，自然会想计算下一个数字。这只需要前两个数字。因此，没有必要在一个vector中记录完整的序列。
*/

#include <iostream>

using namespace std;
unsigned long long fib(size_t n){
    switch(n){
        case 0:return 0;
        case 1:return 1;
        default:return fib(n-2)+fib(n-1);
    }
}

int main()
{
    size_t num{};
    cout<<"请你输入要计算斐波那契数列的个数：";
    cin>>num;
    if(num==0){
        cout<<"0"<<endl;
        return 0;
    }
    for(size_t i{1};i<=num;i++){
        cout<<"fib("<<i<<")="<<fib(i)<<endl;
    }
}
